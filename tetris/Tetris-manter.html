<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Areia Quântica</title>
  <style>
    :root {
        --bg-start: #0a0a2a; /* Azul escuro quase preto */
        --bg-end: #1a0a3a;   /* Roxo escuro quase preto */
        --primary-text: #00e6e6; /* Ciano elétrico */
        --secondary-text: #e600e6; /* Magenta vibrante */
        --canvas-border: #00ffff; /* Ciano neon */
        --button-bg-paused: #e600e6; /* Magenta para pausado */
        --button-text-paused: #ffffff;
        --button-border-paused: #bf00bf;
        --button-bg-running: #00e6e6; /* Ciano para rodando */
        --button-text-running: #ffffff;
        --button-border-running: #00bfbf;
        --neomorphic-bg: #15082d; /* Fundo mais claro para elementos neomórficos */
        --neomorphic-shadow-dark: rgba(0, 0, 0, 0.4);
        --neomorphic-shadow-light: rgba(255, 255, 255, 0.08);
        --score-bg: rgba(21, 8, 45, 0.7); /* Transparente neomórfico para score */
        --select-bg: #2a104a; /* Fundo para select */
        --select-border: #00ffff;
        --select-text: #00e6e6;
    }

    body {
      margin: 0;
      background: linear-gradient(to bottom right, var(--bg-start), var(--bg-end));
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      color: var(--primary-text);
      font-family: 'Space Mono', monospace, sans-serif; /* Fonte mais futurista */
      overflow: hidden;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      overscroll-behavior-y: contain;
      touch-action: manipulation;
    }

    /* Importa uma fonte futurista do Google Fonts */
    @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');

    #main-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 95vw; /* Aumenta a largura máxima para celulares */
        max-height: 95vh; /* Aumenta a altura máxima para celulares */
        gap: 20px; /* Espaço entre os elementos */
        box-sizing: border-box;
        padding: 15px; /* Mais padding para espaçamento em telas menores */
    }

    #game-area-container {
        position: relative;
        border-radius: 25px; /* Bordas mais arredondadas */
        overflow: hidden;
        /* Efeito Neomórfico */
        background: var(--neomorphic-bg);
        box-shadow: 
            7px 7px 15px var(--neomorphic-shadow-dark),
            -7px -7px 15px var(--neomorphic-shadow-light),
            inset 2px 2px 5px var(--neomorphic-shadow-light),
            inset -2px -2px 5px var(--neomorphic-shadow-dark);
        display: flex;
        justify-content: center;
        align-items: center;
        flex-shrink: 0;
    }

    canvas {
      background: #0d0d0d; /* Fundo do canvas mais escuro */
      border: 5px solid var(--canvas-border); /* Borda neon */
      border-radius: 20px; /* Bordas arredondadas do canvas */
      display: block;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      box-sizing: border-box;
      /* Pequena sombra interna para profundidade */
      box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.3);
    }

    #score-panel {
      position: absolute;
      top: 15px;
      right: 15px;
      font-size: 1.3em; /* Fonte um pouco maior */
      font-weight: bold;
      color: var(--secondary-text);
      text-shadow: 0 0 8px var(--secondary-text), 0 0 15px rgba(230, 0, 230, 0.4); /* Efeito neon no texto */
      background-color: var(--score-bg);
      padding: 10px 15px; /* Mais padding */
      border-radius: 20px;
      /* Efeito Neomórfico para o score */
      box-shadow: 
        5px 5px 10px var(--neomorphic-shadow-dark),
        -5px -5px 10px var(--neomorphic-shadow-light);
      z-index: 10;
      min-width: 100px; /* Garante que o painel não encolha demais */
      text-align: center;
    }

    #startPauseButton {
        position: absolute;
        top: 15px;
        left: 15px;
        padding: 10px 18px;
        border-radius: 20px; /* Bordas mais arredondadas */
        border: none; /* Remove a borda padrão */
        font-size: 1.1em;
        cursor: pointer;
        transition: all 0.2s ease-in-out;
        box-sizing: border-box;
        text-align: center;
        width: 120px; /* Largura um pouco maior para o botão */
        height: 50px; /* Altura um pouco maior */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        line-height: 1.3;
        z-index: 10;
        
        /* Neomorfismo para o botão */
        background: var(--neomorphic-bg);
        box-shadow: 
            5px 5px 10px var(--neomorphic-shadow-dark),
            -5px -5px 10px var(--neomorphic-shadow-light);
        color: var(--primary-text); /* Cor padrão do texto */
    }
    
    #startPauseButton span {
        display: block;
        font-weight: bold;
    }

    #startPauseButton.paused {
        background-color: var(--button-bg-paused);
        color: var(--button-text-paused);
        border: 2px solid var(--button-border-paused); /* Borda sutil para o estado */
        box-shadow: 
            inset 2px 2px 5px rgba(255, 255, 255, 0.2),
            inset -2px -2px 5px rgba(0, 0, 0, 0.3),
            5px 5px 10px var(--neomorphic-shadow-dark);
    }

    #startPauseButton.running {
        background-color: var(--button-bg-running);
        color: var(--button-text-running);
        border: 2px solid var(--button-border-running);
        box-shadow: 
            inset 2px 2px 5px rgba(255, 255, 255, 0.2),
            inset -2px -2px 5px rgba(0, 0, 0, 0.3),
            5px 5px 10px var(--neomorphic-shadow-dark);
    }

    #startPauseButton:hover:not(.paused):not(.running) { /* Efeito de hover padrão */
        transform: translateY(-2px);
        box-shadow: 0 8px 16px rgba(0, 255, 255, 0.3), 0 0 20px rgba(0, 255, 255, 0.2);
    }

    #startPauseButton:hover.paused {
        transform: translateY(-2px);
        box-shadow: 0 8px 16px rgba(230, 0, 230, 0.3), 0 0 20px rgba(230, 0, 230, 0.2);
    }
    
    #startPauseButton:hover.running {
        transform: translateY(-2px);
        box-shadow: 0 8px 16px rgba(0, 255, 255, 0.3), 0 0 20px rgba(0, 255, 255, 0.2);
    }

    #startPauseButton:active {
        transform: translateY(0);
        box-shadow: 
            inset 3px 3px 7px var(--neomorphic-shadow-dark),
            inset -3px -3px 7px var(--neomorphic-shadow-light);
    }

    #difficulty-select {
        position: absolute;
        top: 100%; /* Abaixo do botão */
        left: 0;
        width: 100%;
        margin-top: 10px; /* Mais espaço */
        padding: 8px; /* Mais padding */
        border-radius: 15px; /* Bordas arredondadas */
        border: 1px solid var(--select-border); /* Borda neon */
        background-color: var(--select-bg);
        color: var(--select-text);
        font-size: 0.9em;
        cursor: pointer;
        box-sizing: border-box;
        box-shadow: 
            3px 3px 6px var(--neomorphic-shadow-dark),
            -3px -3px 6px var(--neomorphic-shadow-light);
        appearance: none; /* Remove o estilo padrão do select */
        -webkit-appearance: none;
        -moz-appearance: none;
        background-image: url('data:image/svg+xml;utf8,<svg fill="%2300e6e6" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>'); /* Seta customizada */
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 20px;
    }

    #difficulty-select option {
        background-color: var(--select-bg);
        color: var(--select-text);
    }

    #difficulty-select.hidden {
        display: none;
    }

    .dust-particle {
      position: absolute;
      background-color: rgba(0, 255, 255, 0.6); /* Partículas ciano claro */
      border-radius: 50%;
      pointer-events: none;
      animation: fadeOutUp 1s forwards;
      filter: blur(1px);
      z-index: 100;
    }

    @keyframes fadeOutUp {
      0% {
        opacity: 0.8;
        transform: translateY(0) scale(0.8);
      }
      100% {
        opacity: 0;
        transform: translateY(-70px) scale(1.5) rotate(360deg);
      }
    }

    /* Media Queries para Responsividade */
    @media (max-width: 600px) {
        #main-wrapper {
            padding: 10px;
            gap: 15px;
        }

        #score-panel {
            font-size: 1.1em;
            padding: 8px 12px;
            top: 10px;
            right: 10px;
        }

        #startPauseButton {
            width: 100px;
            height: 45px;
            font-size: 1em;
            padding: 8px 12px;
            top: 10px;
            left: 10px;
        }

        #difficulty-select {
            margin-top: 8px;
            font-size: 0.8em;
            padding: 6px;
        }
    }
  </style>
</head>
<body>

<div id="main-wrapper">
    <div id="game-area-container">
        <canvas id="gameCanvas"></canvas>
        <div id="score-panel">
          Score: <span id="scoreValue">0</span>
        </div>
        <button id="startPauseButton" class="paused">
            <span id="button-status-text">Iniciar Jogo</span>
        </button>
    </div>
</div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const NORMAL_GRAVITY = 0.01;
  const FAST_GRAVITY = 5;

  const TILE_SIZE = 20;

  const SAND_CELL_SIZE = 8;
  let COLS; // Serão calculados no resizeCanvas
  let ROWS; // Serão calculados no resizeCanvas

  let sandGrid = [];
  let currentPiece = null;
  let currentGravity = NORMAL_GRAVITY;
  let score = 0;
  let gamePaused = true;
  let animationFrameId;

  let lastSandUpdateTime = 0;
  const SAND_UPDATE_INTERVAL = 50;

  const scoreValueElement = document.getElementById('scoreValue');
  const startPauseButton = document.getElementById('startPauseButton');
  const buttonStatusText = document.getElementById('button-status-text');

  const shapes = {
    T: [[0,0], [1,0], [2,0], [1,1]],
    L: [[0,0], [0,1], [0,2], [1,2]],
    J: [[1,0], [1,1], [1,2], [0,2]],
    I: [[0,0], [0,1], [0,2], [0,3]],
    O: [[0,0], [1,0], [0,1], [1,1]],
    S: [[1,0], [2,0], [0,1], [1,1]],
    Z: [[0,0], [1,0], [1,1], [2,1]]
  };

  // Cores futuristas/neon
  const allColors = [
    '#00ffff', // Ciano Neon
    '#ff00ff', // Magenta Neon
    '#00ff00', // Verde Neon
    '#ffff00', // Amarelo Neon
    '#ff4500', // Laranja Elétrico
    '#8A2BE2', // Azul Violeta
    '#ADFF2F'  // Verde Amarelo Claro
  ];

  let availableColors = [];
  let currentDifficulty = 'easy';

  // --- Funções de UI e Game State ---
  function updateScoreDisplay() {
    scoreValueElement.textContent = score;
  }

  // --- Funções de Jogo ---
  function drawGame() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (currentPiece) {
        ctx.fillStyle = currentPiece.color;
        // Desenha os blocos com bordas arredondadas
        for (const b of currentPiece.blocks) {
            ctx.beginPath();
            ctx.roundRect(currentPiece.x + b.x, currentPiece.y + b.y, TILE_SIZE, TILE_SIZE, 5); // Arredonda os cantos
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.2)'; // Borda sutil para separar blocos
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const color = sandGrid[y][x];
        if (color !== null) {
          ctx.fillStyle = color;
          ctx.beginPath();
          const centerX = x * SAND_CELL_SIZE + SAND_CELL_SIZE / 2;
          const centerY = y * SAND_CELL_SIZE + SAND_CELL_SIZE / 2;
          const radius = SAND_CELL_SIZE / 2;
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  function getRandomShapeType() {
    const types = Object.keys(shapes);
    return types[Math.floor(Math.random() * types.length)];
  }

  function getRandomColor() {
    return availableColors[Math.floor(Math.random() * availableColors.length)];
  }

  function addSandToGridFromPiece(p) {
    for (const b of p.blocks) {
      const bx = p.x + b.x;
      const by = p.y + b.y;

      for (let y = 0; y < TILE_SIZE; y += SAND_CELL_SIZE) {
        for (let x = 0; x < TILE_SIZE; x += SAND_CELL_SIZE) {
          const gridX = Math.floor((bx + x) / SAND_CELL_SIZE);
          const gridY = Math.floor((by + y) / SAND_CELL_SIZE);

          if (gridX >= 0 && gridX < COLS && gridY >= 0 && gridY < ROWS) {
            sandGrid[gridY][gridX] = p.color;
          }
        }
      }
    }
  }

  function checkCollision(piece, offsetX = 0, offsetY = 0) {
    for (const b of piece.blocks) {
      const newBX = piece.x + b.x + offsetX;
      const newBY = piece.y + b.y + offsetY;

      // Colisão com as bordas do canvas
      if (newBX < 0 || newBX + TILE_SIZE > canvas.width || newBY + TILE_SIZE > canvas.height) {
        return true;
      }

      // Colisão com a areia existente
      for (let yOffset = 0; yOffset < TILE_SIZE; yOffset += SAND_CELL_SIZE) {
        for (let xOffset = 0; xOffset < TILE_SIZE; xOffset += SAND_CELL_SIZE) {
          const gridX = Math.floor((newBX + xOffset) / SAND_CELL_SIZE);
          const gridY = Math.floor((newBY + yOffset) / SAND_CELL_SIZE);

          // Verifica se está dentro dos limites da grade de areia antes de acessar
          if (gridX >= 0 && gridX < COLS && gridY >= 0 && gridY < ROWS && sandGrid[gridY][gridX] !== null) {
            return true;
          }
        }
      }
    }
    return false;
  }

  // Função para girar a peça (similar ao Tetris original)
  function rotatePiece() {
    if (!currentPiece || gamePaused) return;

    // A rotação simples é para Tetrominoes de 4 blocos.
    // Para shapes como 'O' (quadrado), a rotação não faz diferença, ou o 'I' em 90 graus.
    // Implementação básica de rotação 90 graus no sentido horário
    const originalBlocks = currentPiece.blocks;
    const centerBlock = currentPiece.blocks[1]; // Supondo o segundo bloco como ponto de rotação, comum em Tetris

    // Crie uma nova peça temporária para testar a rotação
    const rotatedBlocks = originalBlocks.map(b => {
        // Coordenadas relativas ao centro de rotação (ajuste se seu ponto de rotação for diferente)
        const relativeX = b.x - centerBlock.x;
        const relativeY = b.y - centerBlock.y;
        // Rotação 90 graus no sentido horário: newX = -relativeY, newY = relativeX
        return { x: centerBlock.x + (-relativeY), y: centerBlock.y + relativeX };
    });

    const testPiece = { ...currentPiece, blocks: rotatedBlocks };

    // Verifica colisão após rotação
    if (!checkCollision(testPiece)) {
        currentPiece.blocks = rotatedBlocks;
    } else {
        // Se houver colisão, tenta "chutar" a peça para uma posição válida
        // Regras de "kick" do Tetris (SRS - Super Rotation System) são complexas,
        // mas podemos tentar um deslocamento simples.
        const kicks = [
            {x: 0, y: 0},    // Nenhuma mudança
            {x: TILE_SIZE, y: 0}, // Move para direita
            {x: -TILE_SIZE, y: 0},// Move para esquerda
            {x: 0, y: -TILE_SIZE} // Move para cima (raro, mas possível em alguns casos)
        ];

        for (const kick of kicks) {
            const kickedTestPiece = { ...testPiece, x: testPiece.x + kick.x, y: testPiece.y + kick.y };
            if (!checkCollision(kickedTestPiece)) {
                currentPiece.blocks = rotatedBlocks;
                currentPiece.x = kickedTestPiece.x;
                currentPiece.y = kickedTestPiece.y;
                break; // Encontrou uma posição válida, sai
            }
        }
    }
  }

  function updateSandSimulation() {
    for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        const currentColor = sandGrid[y][x];

        if (currentColor !== null) {
          if (y + 1 < ROWS && sandGrid[y + 1][x] === null) {
            sandGrid[y + 1][x] = currentColor;
            sandGrid[y][x] = null;
          } else if (y + 1 < ROWS) {
            const rollOrder = Math.random() < 0.5 ? [-1, 1] : [1, -1];

            let moved = false;
            for (const rollDirection of rollOrder) {
              const rollX = x + rollDirection;
              if (rollX >= 0 && rollX < COLS && sandGrid[y + 1][rollX] === null) {
                sandGrid[y + 1][rollX] = currentColor;
                sandGrid[y][x] = null;
                moved = true;
                break;
              }
            }
          }
        }
      }
    }
  }

  function createDustEffect(startColor, x, y, width, height) {
    const numParticles = 15;
    const container = document.body;

    for (let i = 0; i < numParticles; i++) {
      const particle = document.createElement('div');
      particle.className = 'dust-particle';
      const size = Math.random() * 4 + 2;
      particle.style.width = `${size}px`;
      particle.style.height = `${size}px`;

      const particleX = x + Math.random() * width;
      const particleY = y + Math.random() * height;
      
      const canvasRect = canvas.getBoundingClientRect();
      particle.style.left = `${canvasRect.left + particleX}px`;
      particle.style.top = `${canvasRect.top + particleY}px`;
      
      particle.style.backgroundColor = `rgba(0, 255, 255, ${Math.random() * 0.4 + 0.4})`; // Ciano mais forte para partículas
      particle.style.animationDuration = `${Math.random() * 0.4 + 0.6}s`;
      particle.style.animationDelay = `${Math.random() * 0.05}s`;

      container.appendChild(particle);

      particle.addEventListener('animationend', () => {
        particle.remove();
      });
    }
  }

  function calculateScore(linesDestroyed) {
      let baseScore = 100;
      let totalScore = 0;
      for (let i = 0; i < linesDestroyed; i++) {
          totalScore += baseScore + (i * 100);
      }
      return totalScore;
  }

  function checkAndDestroySandLines() {
    let visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
    let linesDestroyedInThisCheck = 0;

    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const currentColor = sandGrid[y][x];

        if (currentColor !== null && !visited[y][x]) {
          let clusterPixels = [];
          let queue = [{ r: y, c: x }];
          visited[y][x] = true;
          let minCol = COLS;
          let maxCol = -1;
          let minRow = ROWS;
          let maxRow = -1;

          let head = 0;
          while (head < queue.length) {
            const { r, c } = queue[head++];

            clusterPixels.push({ r, c });
            minCol = Math.min(minCol, c);
            maxCol = Math.max(maxCol, c);
            minRow = Math.min(minRow, r);
            maxRow = Math.max(maxRow, r);

            const dr = [-1, -1, -1, 0, 0, 1, 1, 1];
            const dc = [-1, 0, 1, -1, 1, -1, 0, 1];

            for (let i = 0; i < 8; i++) {
              const nr = r + dr[i];
              const nc = c + dc[i];

              if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS &&
                  !visited[nr][nc] && sandGrid[nr][nc] === currentColor) {
                visited[nr][nc] = true;
                queue.push({ r: nr, c: nc });
              }
            }
          }

          if (minCol === 0 && maxCol === COLS - 1) { // Verifica se a linha completa de sand_cell_size
            const effectX = minCol * SAND_CELL_SIZE;
            const effectY = minRow * SAND_CELL_SIZE;
            const effectWidth = (maxCol - minCol + 1) * SAND_CELL_SIZE;
            const effectHeight = (maxRow - minRow + 1) * SAND_CELL_SIZE;

            createDustEffect(currentColor, effectX, effectY, effectWidth, effectHeight);

            for (const p of clusterPixels) {
              sandGrid[p.r][p.c] = null;
            }
            linesDestroyedInThisCheck++;
          }
        }
      }
    }
    
    if (linesDestroyedInThisCheck > 0) {
        score += calculateScore(linesDestroyedInThisCheck);
        updateScoreDisplay();
        return true; // Indica que linhas foram destruídas
    }
    return false; // Indica que nenhuma linha foi destruída
  }

  function spawnNewPiece() {
    // NOVO: Verifica e destrói linhas em cascata ANTES de spawnar a nova peça
    let linesDestroyedCascading = true;
    while(linesDestroyedCascading) {
        linesDestroyedCascading = checkAndDestroySandLines();
        // Opcional: Para uma visualização mais suave da queda da areia,
        // você poderia adicionar um pequeno atraso aqui, mas para "uma única verificação"
        // sem pausa no jogo, é melhor deixá-lo fora.
        // Se a verificação precisar de mais de uma iteração para limpar, ela fará.
        if (linesDestroyedCascading) { // Se algo foi destruído, atualiza a simulação da areia para que o que sobrou caia
            updateSandSimulation(); 
        }
    }


    const type = getRandomShapeType();
    const color = getRandomColor();
    const startX = Math.floor((canvas.width / 2 - (shapes[type].length / 2 * TILE_SIZE)) / TILE_SIZE) * TILE_SIZE;
    
    const testPiece = {
        x: startX,
        y: 0,
        blocks: shapes[type].map(([dx, dy]) => ({ x: dx * TILE_SIZE, y: dy * TILE_SIZE })),
        color: color
    };

    if (checkCollision(testPiece)) {
        gamePaused = true;
        updateGameStatus();
        alert("Game Over! Sua areia atingiu o topo.");
        resetGame(false);
        return;
    }

    currentPiece = {
      x: startX,
      y: 0,
      blocks: shapes[type].map(([dx, dy]) => ({ x: dx * TILE_SIZE, y: dy * TILE_SIZE })),
      color: color,
      velocityY: 0,
      grounded: false
    };
    currentGravity = NORMAL_GRAVITY;
  }

  function attemptMove(direction) {
    if (!currentPiece || gamePaused) return;

    let newX = currentPiece.x;

    if (direction === 'left') {
      newX -= TILE_SIZE;
    } else if (direction === 'right') {
      newX += TILE_SIZE;
    } 

    const testPiece = { ...currentPiece, x: newX };
    if (!checkCollision(testPiece)) {
      currentPiece.x = newX;
    }
  }

  function activateFastDrop() {
      if (currentPiece && !gamePaused) {
          currentGravity = FAST_GRAVITY;
      }
  }

  // --- Controles de Teclado (Mantidos para desktop) ---
  document.addEventListener('keydown', (e) => {
    if (e.repeat || gamePaused) return;

    switch (e.key) {
      case 'ArrowLeft':
        attemptMove('left');
        break;
      case 'ArrowRight':
        attemptMove('right');
        break;
      case 'ArrowDown':
        activateFastDrop();
        break;
      case 'ArrowUp': // Adicionado para rotação no teclado
        rotatePiece();
        break;
      case ' ':
        startPauseButton.click();
        break;
    }
  });

  document.addEventListener('keyup', (e) => {
    if (gamePaused) return;
    switch (e.key) {
      case 'ArrowDown':
        currentGravity = NORMAL_GRAVITY;
        break;
    }
  });

  const difficultyNames = {
      'easy': 'Fácil',
      'medium': 'Médio',
      'hard': 'Difícil'
  };

  function setDifficultyColors(level) {
      currentDifficulty = level;
      switch(level) {
          case 'easy':
              availableColors = allColors.slice(0, 3);
              break;
          case 'medium':
              availableColors = allColors.slice(0, 4);
              break;
          case 'hard':
              availableColors = allColors.slice(0, 5);
              break;
          default:
              availableColors = allColors.slice(0, 3);
      }
  }

  const difficultySelect = document.createElement('select');
  difficultySelect.id = 'difficulty-select';
  ['easy', 'medium', 'hard'].forEach(level => {
      const option = document.createElement('option');
      option.value = level;
      option.textContent = `${difficultyNames[level]} (${allColors.slice(0, {easy:3, medium:4, hard:5}[level]).length} Cores)`;
      difficultySelect.appendChild(option);
  });
  startPauseButton.appendChild(difficultySelect); 

  function updateGameStatus() {
      if (gamePaused) {
          buttonStatusText.textContent = "Iniciar Jogo";
          startPauseButton.classList.remove('running');
          startPauseButton.classList.add('paused');
          cancelAnimationFrame(animationFrameId);
          difficultySelect.classList.remove('hidden'); // Mostra o seletor quando pausado
      } else {
          buttonStatusText.textContent = "Pausar Jogo";
          startPauseButton.classList.remove('paused');
          startPauseButton.classList.add('running');
          animationFrameId = requestAnimationFrame(update);
          difficultySelect.classList.add('hidden'); // Esconde o seletor quando rodando
      }
  }

  startPauseButton.addEventListener('click', (event) => {
      if (event.target.tagName === 'SELECT') { // Impede que o clique no select pause/inicie
          return;
      }
      gamePaused = !gamePaused;
      if (!currentPiece && !gamePaused) {
          spawnNewPiece();
      }
      updateGameStatus();
  });

  difficultySelect.addEventListener('change', () => {
      if (gamePaused) { // Apenas permite mudar a dificuldade se o jogo estiver pausado
          setDifficultyColors(difficultySelect.value);
          resetGame(false); // Reseta o jogo para aplicar a nova cor, mas não a dificuldade novamente.
      }
  });

  function resetGame(shouldResetDifficulty = false) {
      sandGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
      score = 0;
      updateScoreDisplay();
      if (shouldResetDifficulty) {
          setDifficultyColors(difficultySelect.value);
      }
      currentPiece = null;
      drawGame();
  }

  // --- Lógica de Arrastar no Canvas (Movimento lateral) ---
  let isDraggingCanvas = false;
  let dragStartX = 0;
  let currentDragX = 0;
  const DRAG_SENSITIVITY = TILE_SIZE * 0.5;

  function handlePointerStart(e) {
      if (gamePaused) return;
      e.preventDefault();
      isDraggingCanvas = true;
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      dragStartX = clientX;
      currentDragX = clientX;
  }

  function handlePointerMove(e) {
      if (!isDraggingCanvas || gamePaused) return;
      e.preventDefault();

      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      currentDragX = clientX;

      const totalDeltaFromStart = clientX - dragStartX;

      if (Math.abs(totalDeltaFromStart) >= DRAG_SENSITIVITY) {
          if (totalDeltaFromStart > 0) {
              attemptMove('right');
          } else {
              attemptMove('left');
          }
          dragStartX = clientX; 
      }
  }

  function handlePointerEnd() {
      isDraggingCanvas = false;
      dragStartX = 0;
      currentDragX = 0;
  }

  canvas.addEventListener('mousedown', handlePointerStart, { passive: false });
  document.addEventListener('mousemove', handlePointerMove, { passive: false });
  document.addEventListener('mouseup', handlePointerEnd, { passive: false });

  // --- Lógica de Toque para Mobile ---
  let touchStartTime = 0;
  let touchStartX = 0;
  let touchStartY = 0;
  let touchCount = 0;
  const TAP_MAX_DURATION = 200; // ms

  canvas.addEventListener('touchstart', (e) => {
    if (gamePaused) return;
    e.preventDefault(); // Impede o zoom e scroll padrão
    touchCount = e.touches.length;
    touchStartTime = new Date().getTime();
    
    if (touchCount === 1) { // Inicia arrasto para movimento lateral
        isDraggingCanvas = true;
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        dragStartX = touchStartX; // Reutiliza para o drag lateral
        currentDragX = touchStartX;
    } else if (touchCount === 2) { // Dois dedos para fast drop
        isDraggingCanvas = false; // Desativa o drag lateral se for double touch
        activateFastDrop();
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    if (gamePaused || !isDraggingCanvas || touchCount !== 1) return; // Só move com 1 dedo
    e.preventDefault();
    const clientX = e.touches[0].clientX;
    currentDragX = clientX;

    const totalDeltaFromStart = clientX - dragStartX;

    if (Math.abs(totalDeltaFromStart) >= DRAG_SENSITIVITY) {
        if (totalDeltaFromStart > 0) {
            attemptMove('right');
        } else {
            attemptMove('left');
        }
        dragStartX = clientX; 
    }
  }, { passive: false });

  canvas.addEventListener('touchend', (e) => {
    if (gamePaused) return;

    const currentTime = new Date().getTime();
    // Se o toque terminou e foi um toque simples rápido (tap)
    if (e.changedTouches.length === 1 && (currentTime - touchStartTime < TAP_MAX_DURATION)) {
        // Se a "arrastada" foi mínima, consideramos um toque para girar
        const deltaX = Math.abs(e.changedTouches[0].clientX - touchStartX);
        const deltaY = Math.abs(e.changedTouches[0].clientY - touchStartY);
        const TAP_DRAG_TOLERANCE = 10; // Pixels de tolerância para arrastar

        if (deltaX < TAP_DRAG_TOLERANCE && deltaY < TAP_DRAG_TOLERANCE) {
            rotatePiece();
        }
    }
    
    isDraggingCanvas = false; // Reseta o estado do drag
    currentGravity = NORMAL_GRAVITY; // Reseta a gravidade após qualquer toque
    touchCount = 0; // Reseta a contagem de toques
  });

  canvas.addEventListener('touchcancel', (e) => {
    isDraggingCanvas = false;
    currentGravity = NORMAL_GRAVITY;
    touchCount = 0;
  });


  // --- Gerenciamento de Redimensionamento do Canvas ---
  function resizeCanvas() {
      const mainWrapper = document.getElementById('main-wrapper');
      const gameAreaContainer = document.getElementById('game-area-container');

      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Ajusta o max-width/height do wrapper para garantir que ele não seja maior que a viewport
      mainWrapper.style.maxWidth = `${viewportWidth * 0.95}px`;
      mainWrapper.style.maxHeight = `${viewportHeight * 0.95}px`;

      // Calcula o espaço disponível para o canvas, considerando o padding do wrapper e o gap
      // Vamos tentar manter uma proporção 3:5 (largura:altura) para o canvas, como antes
      let targetAspectRatio = 300 / 500; // Largura / Altura

      let newCanvasWidth = viewportWidth * 0.8; // Começa com 80% da largura da viewport
      let newCanvasHeight = newCanvasWidth / targetAspectRatio;

      // Se a altura calculada for maior que a altura disponível, ajusta pela altura
      if (newCanvasHeight > (viewportHeight * 0.8)) { // 80% da altura da viewport
          newCanvasHeight = viewportHeight * 0.8;
          newCanvasWidth = newCanvasHeight * targetAspectRatio;
      }

      // Limites máximos para o canvas (para telas grandes)
      newCanvasWidth = Math.min(newCanvasWidth, 450);
      newCanvasHeight = Math.min(newCanvasHeight, 750);
      
      // Garante que a largura e altura sejam múltiplos de TILE_SIZE * 2 ou de SAND_CELL_SIZE,
      // para evitar problemas de arredondamento e garantir que as peças se encaixem bem
      newCanvasWidth = Math.floor(newCanvasWidth / TILE_SIZE) * TILE_SIZE;
      newCanvasHeight = Math.floor(newCanvasHeight / TILE_SIZE) * TILE_SIZE;


      canvas.width = newCanvasWidth;
      canvas.height = newCanvasHeight;

      COLS = Math.floor(canvas.width / SAND_CELL_SIZE);
      ROWS = Math.floor(canvas.height / SAND_CELL_SIZE);

      // Recria a grade de areia se as dimensões mudarem
      if (sandGrid.length !== ROWS || (sandGrid[0] && sandGrid[0].length !== COLS)) {
        sandGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
      }
      
      gameAreaContainer.style.width = `${canvas.width}px`;
      gameAreaContainer.style.height = `${canvas.height}px`;
  }

  window.addEventListener('resize', resizeCanvas);


  // --- Loop Principal do Jogo ---
  function update(currentTime) {
    if (gamePaused) {
        return;
    }

    if (currentTime - lastSandUpdateTime > SAND_UPDATE_INTERVAL) {
        updateSandSimulation();
        lastSandUpdateTime = currentTime;
    }

    if (currentPiece) {
      currentPiece.velocityY += currentGravity;
      const testPiece = { ...currentPiece, y: currentPiece.y + currentPiece.velocityY };

      if (!checkCollision(testPiece)) { // Se não há colisão na nova posição, move
        currentPiece.y = testPiece.y; // Atualiza para a nova posição
      } else { // Se há colisão na nova posição
        // MOVE A PEÇA PARA A ÚLTIMA POSIÇÃO VÁLIDA ANTES DA COLISÃO TOTAL
        let finalY = currentPiece.y;
        while (!checkCollision({ ...currentPiece, y: finalY + 1}) && (finalY + TILE_SIZE) < canvas.height) {
            finalY += 1;
        }
        currentPiece.y = finalY;

        addSandToGridFromPiece(currentPiece);
        currentPiece = null;
        currentGravity = NORMAL_GRAVITY;
        
        // REMOVIDO DAQUI: A lógica de checkAndDestroySandLines em loop
        // Agora ela é chamada apenas no spawnNewPiece()
      }
    } else {
        spawnNewPiece(); // A nova peça só vai aparecer depois da limpeza da areia
    }

    drawGame();

    animationFrameId = requestAnimationFrame(update);
  }

  // --- Inicialização do Jogo ---
  setDifficultyColors(difficultySelect.value);
  resizeCanvas(); // Chama no início para definir o tamanho inicial
  updateScoreDisplay();
  updateGameStatus(); // Para garantir que o seletor esteja visível no início
  drawGame();
  
</script>

</body>
</html>
